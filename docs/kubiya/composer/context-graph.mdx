---
title: "Context Graph"
description: "Comprehensive guide to the Context Graph - intelligent resource discovery and relationship mapping"
icon: "project-diagram"
---

# Context Graph

The Context Graph is Composer's intelligent system for discovering, mapping, and understanding the relationships between all your infrastructure resources, applications, and data sources. It provides AI agents with comprehensive context about your environment to make smarter automation decisions.

## Understanding the Context Graph

### What Is the Context Graph?
The Context Graph is a dynamic, real-time representation of your entire technology ecosystem that:
- **Maps Relationships**: Discovers connections between services, databases, APIs, and infrastructure
- **Tracks Dependencies**: Understands which components depend on others
- **Provides Context**: Gives AI agents intelligent awareness of your environment
- **Enables Discovery**: Helps users and agents find relevant resources quickly
- **Predicts Impact**: Analyzes potential effects of changes across your system

### Graph Architecture
```yaml
Graph Components:
  Nodes: Individual resources (services, databases, APIs)
  Edges: Relationships and connections between resources
  Attributes: Metadata and properties of each resource
  Contexts: Logical groupings and categorizations
  Policies: Access controls and governance rules
  History: Change tracking and evolution over time
```

## Visualization Interface

### Graph Navigation
Access the Context Graph through **Context Graph** in the main navigation:

#### Main Graph View
- **Interactive Canvas**: Pan, zoom, and explore your resource landscape
- **Node Types**: Different shapes and colors for various resource types
- **Relationship Lines**: Visual connections showing dependencies
- **Clustering**: Automatic grouping of related resources
- **Search Overlay**: Find specific resources quickly

#### View Modes

<CardGroup cols={2}>
  <Card title="Network View" icon="network-wired">
    Traditional node-and-edge graph visualization
  </Card>
  <Card title="Hierarchical View" icon="sitemap">
    Tree-like structure showing resource hierarchy
  </Card>
  <Card title="Timeline View" icon="timeline">
    Resource changes and relationships over time
  </Card>
  <Card title="Impact View" icon="bullseye">
    Focus on dependencies and impact analysis
  </Card>
</CardGroup>

### Interactive Features

#### Node Interaction
Click any resource node to see:
```yaml
Resource Details Panel:
  Basic Information:
    - Resource name and type
    - Current status and health
    - Last updated timestamp
    - Owner and team information
  
  Technical Details:
    - Configuration summary
    - Performance metrics
    - Security posture
    - Cost information
  
  Relationships:
    - Incoming dependencies (what depends on this)
    - Outgoing dependencies (what this depends on)
    - Related resources (similar or grouped)
    - Network connections
```

#### Relationship Exploration
- **Hover Effects**: Preview relationship details on hover
- **Path Tracing**: Trace connections between any two resources
- **Dependency Chains**: Follow complete dependency paths
- **Impact Radius**: See all resources affected by changes

## Resource Discovery

### Automatic Discovery
The Context Graph automatically discovers resources through:

#### Integration-Based Discovery
```yaml
Discovery Sources:
  Cloud Platforms:
    - AWS: EC2, RDS, S3, Lambda, etc.
    - Azure: VMs, SQL, Storage, Functions
    - GCP: Compute, Cloud SQL, Storage, Cloud Functions
  
  Container Orchestration:
    - Kubernetes: Pods, Services, Ingress, ConfigMaps
    - Docker: Containers, Networks, Volumes
  
  CI/CD Systems:
    - GitHub Actions: Workflows, Repositories
    - GitLab CI: Pipelines, Projects
    - Jenkins: Jobs, Nodes
  
  Monitoring Systems:
    - Prometheus: Metrics, Targets
    - Grafana: Dashboards, Data Sources
    - Datadog: Hosts, Services, Logs
```

#### Network Discovery
- **Network Scanning**: Discover services by network connectivity
- **Port Analysis**: Identify running services and open ports
- **Protocol Detection**: Recognize service types by protocol
- **Traffic Analysis**: Map communication patterns

#### Configuration Discovery
- **Config File Parsing**: Extract resource definitions from configuration
- **Environment Variables**: Discover service connections through env vars
- **DNS Analysis**: Map service discovery through DNS records
- **Load Balancer Analysis**: Trace traffic routing and destinations

### Manual Resource Registration
Add resources not automatically discovered:

<Steps>
  <Step title="Add Resource">
    Click **"Add Resource"** in the Context Graph interface
  </Step>
  
  <Step title="Select Resource Type">
    Choose from available resource categories
  </Step>
  
  <Step title="Configure Details">
    Provide resource information and connection details
  </Step>
  
  <Step title="Define Relationships">
    Map connections to existing resources
  </Step>
  
  <Step title="Validate and Save">
    Test connectivity and save to the graph
  </Step>
</Steps>

## Resource Types and Categories

### Infrastructure Resources

#### Compute Resources
```yaml
Virtual Machines:
  attributes: ["cpu", "memory", "storage", "os"]
  relationships: ["networks", "load_balancers", "security_groups"]
  
Containers:
  attributes: ["image", "resources", "environment"]
  relationships: ["pods", "services", "volumes"]
  
Serverless Functions:
  attributes: ["runtime", "memory", "timeout"]
  relationships: ["triggers", "databases", "apis"]
```

#### Storage Resources
```yaml
Databases:
  attributes: ["engine", "version", "size", "performance"]
  relationships: ["applications", "backups", "replicas"]
  
File Storage:
  attributes: ["type", "capacity", "encryption"]
  relationships: ["applications", "backup_jobs"]
  
Object Storage:
  attributes: ["buckets", "objects", "access_policies"]
  relationships: ["applications", "cdn", "backup_systems"]
```

### Application Resources

#### Services and APIs
```yaml
Microservices:
  attributes: ["language", "framework", "version"]
  relationships: ["dependencies", "databases", "queues"]
  
REST APIs:
  attributes: ["endpoints", "authentication", "rate_limits"]
  relationships: ["clients", "backends", "gateways"]
  
Message Queues:
  attributes: ["engine", "topics", "consumers"]
  relationships: ["producers", "consumers", "dead_letter_queues"]
```

#### Development Resources
```yaml
Git Repositories:
  attributes: ["language", "size", "contributors"]
  relationships: ["ci_pipelines", "deployments", "issues"]
  
CI/CD Pipelines:
  attributes: ["stages", "triggers", "success_rate"]
  relationships: ["repositories", "deployments", "artifacts"]
```

## Relationship Mapping

### Relationship Types
The Context Graph recognizes various relationship patterns:

#### Dependency Relationships
```yaml
depends_on: Service A requires Service B to function
uses: Application uses Database for storage
calls: API Client calls API Server
consumes: Consumer reads from Message Queue
```

#### Composition Relationships
```yaml
contains: Kubernetes Namespace contains Pods
includes: Load Balancer includes Backend Services
hosts: Virtual Machine hosts Application
runs_on: Container runs on Kubernetes Node
```

#### Network Relationships
```yaml
connects_to: Direct network connection
routes_to: Traffic routing relationship
proxies_to: Proxy or gateway relationship
load_balances: Load balancer to backend relationship
```

### Automatic Relationship Detection
The system automatically detects relationships through:

#### Configuration Analysis
```yaml
Detection Methods:
  Environment Variables:
    DATABASE_URL → Database connection
    API_ENDPOINT → API service dependency
    QUEUE_NAME → Message queue usage
  
  Network Traffic:
    TCP connections → Service dependencies
    HTTP requests → API relationships
    Database queries → Data dependencies
  
  Configuration Files:
    docker-compose.yml → Container relationships
    kubernetes.yaml → Pod and service relationships
    terraform.tf → Infrastructure dependencies
```

#### Runtime Analysis
- **Process Monitoring**: Track process communication
- **Network Flow Analysis**: Monitor network traffic patterns
- **API Call Tracing**: Trace API request/response patterns
- **Database Query Analysis**: Map data access patterns

## AI Context Enhancement

### How Agents Use the Context Graph
AI agents leverage the Context Graph to:

#### Intelligent Decision Making
```yaml
Use Cases:
  Deployment Decisions:
    - Choose appropriate deployment targets
    - Understand blast radius of changes
    - Identify required dependencies
  
  Troubleshooting:
    - Trace problem sources across systems
    - Identify affected downstream services
    - Suggest appropriate fixes
  
  Security Analysis:
    - Map attack surfaces and vulnerabilities
    - Trace data flow for compliance
    - Identify access control gaps
```

#### Smart Automation
- **Impact Analysis**: Understand consequences before making changes
- **Resource Optimization**: Identify unused or underutilized resources
- **Capacity Planning**: Predict resource needs based on relationships
- **Incident Response**: Automatically identify related systems during outages

### Context-Aware Suggestions
The graph enables intelligent suggestions:

#### Resource Recommendations
```yaml
Suggestion Types:
  Similar Resources:
    "Based on your current setup, you might also need..."
  
  Missing Dependencies:
    "To deploy this service, you'll also need to configure..."
  
  Optimization Opportunities:
    "These resources could be consolidated to reduce costs..."
  
  Security Improvements:
    "Consider adding encryption between these services..."
```

## Graph Management

### Data Quality and Accuracy

#### Automatic Validation
```yaml
Validation Processes:
  Connectivity Tests:
    - Verify network reachability
    - Test API endpoints
    - Validate database connections
  
  Configuration Checks:
    - Parse and validate config files
    - Check for configuration drift
    - Identify orphaned resources
  
  Health Monitoring:
    - Monitor resource status
    - Track performance metrics
    - Alert on failures
```

#### Data Cleanup
- **Stale Resource Removal**: Automatically remove deleted resources
- **Duplicate Detection**: Identify and merge duplicate entries
- **Relationship Validation**: Verify relationship accuracy
- **Data Normalization**: Standardize resource attributes

### Graph Evolution Tracking

#### Change History
Track how your environment evolves:
```yaml
Change Tracking:
  Resource Changes:
    - Creation and deletion events
    - Configuration modifications
    - Status and health changes
  
  Relationship Changes:
    - New connections established
    - Dependencies removed
    - Relationship type changes
  
  Topology Changes:
    - Network topology updates
    - Service architecture evolution
    - Infrastructure scaling events
```

#### Version Control
- **Graph Snapshots**: Save point-in-time graph states
- **Change Diffs**: Compare graph states across time periods
- **Rollback Capability**: Restore previous graph configurations
- **Audit Trail**: Complete history of all graph modifications

## Advanced Features

### Graph Analytics

#### Metrics and Insights
```yaml
Analysis Capabilities:
  Centrality Analysis:
    - Identify critical nodes in your infrastructure
    - Find single points of failure
    - Discover communication hubs
  
  Cluster Detection:
    - Identify tightly coupled service groups
    - Find isolated components
    - Discover architectural patterns
  
  Path Analysis:
    - Find shortest paths between services
    - Identify bottlenecks and choke points
    - Optimize communication flows
```

#### Performance Analytics
- **Response Time Analysis**: Map performance across service chains
- **Throughput Tracking**: Identify high-traffic paths
- **Error Propagation**: Track how errors spread through systems
- **Resource Utilization**: Correlate usage across dependent systems

### Policy and Governance

#### Access Control
```yaml
Security Policies:
  Resource Visibility:
    - Control who can see which resources
    - Mask sensitive resource details
    - Implement role-based access
  
  Relationship Access:
    - Restrict access to sensitive connections
    - Hide internal implementation details
    - Protect security-critical relationships
```

#### Compliance Mapping
- **Data Flow Tracking**: Map data movement for compliance
- **Security Boundary Identification**: Identify security zones
- **Access Pattern Analysis**: Monitor and audit access patterns
- **Regulatory Reporting**: Generate compliance reports

## Troubleshooting the Context Graph

### Common Issues

#### Missing Resources
```yaml
Troubleshooting Steps:
  1. Verify integration configurations
  2. Check discovery scope settings
  3. Review access permissions
  4. Manually add missing resources
  5. Validate network connectivity

Resolution Actions:
  - Update integration credentials
  - Expand discovery scope
  - Adjust firewall rules
  - Enable additional data sources
```

#### Incorrect Relationships
```yaml
Diagnosis Steps:
  1. Review relationship detection logic
  2. Check configuration parsing
  3. Validate network traffic analysis
  4. Examine manual relationship entries

Correction Actions:
  - Update detection rules
  - Fix configuration formats
  - Adjust traffic analysis settings
  - Manually correct relationships
```

#### Performance Issues
```yaml
Performance Optimization:
  Large Graphs:
    - Enable graph clustering
    - Implement lazy loading
    - Use graph filtering
    - Optimize rendering settings
  
  Slow Updates:
    - Adjust refresh intervals
    - Optimize discovery queries
    - Enable incremental updates
    - Scale processing resources
```

## Best Practices

### Graph Design Principles

#### Comprehensive Coverage
- **Complete Discovery**: Ensure all critical resources are mapped
- **Regular Updates**: Keep the graph current with infrastructure changes
- **Relationship Accuracy**: Validate and maintain relationship accuracy
- **Context Enrichment**: Add meaningful metadata and attributes

#### Performance Optimization
- **Selective Discovery**: Focus on relevant resources for your use cases
- **Efficient Querying**: Optimize graph queries for performance
- **Caching Strategy**: Implement appropriate caching for frequently accessed data
- **Resource Management**: Monitor and manage graph storage and compute resources

### Integration Strategy
- **Start Small**: Begin with core infrastructure and expand gradually
- **Prioritize Critical Systems**: Focus on business-critical resources first
- **Iterative Improvement**: Continuously refine discovery and relationships
- **User Feedback**: Gather feedback from AI agents and users for improvements

---

*The Context Graph is the intelligence layer that makes your AI automation truly context-aware. Invest in building and maintaining a comprehensive, accurate graph to unlock the full potential of intelligent automation.*