---
title: "Workflows Overview"
description: "Build automated sequences that run reliably in containers"
sidebarTitle: "Overview"
icon: "diagram-project"
---

Workflows are sequences of automated steps that accomplish complex tasks safely and reliably using containers.

## What workflows do

**Run steps in containers:** Each step runs in its own Docker container with specific tools and dependencies.

**Connect step outputs:** Pass data between steps to build complex automation sequences.

**Handle failures gracefully:** Built-in retry logic and error handling keep workflows robust.

**Execute in parallel:** Independent steps run simultaneously for faster completion.

**Integrate AI agents:** Include intelligent decision-making within deterministic workflows.

## Basic workflow structure

```python
from kubiya import workflow, step

@workflow
def deploy_application():
    # Step 1: Run tests in Node.js container
    test_results = step.run_tests(
        image="node:18",
        script="npm test"
    )
    
    # Step 2: Build Docker image
    app_image = step.build_image(
        dockerfile="./Dockerfile",
        tag="myapp:latest"
    )
    
    # Step 3: Deploy to Kubernetes
    step.deploy(
        image=app_image.tag,
        manifest="k8s/deployment.yaml"
    )
```

## Key benefits

**Reliable:** Same inputs produce same outputs every time - no surprises in production.

**Isolated:** Each step runs in its own container, preventing conflicts and dependency issues.

**Language-agnostic:** Use Python, Node.js, Go, or any language/tool you need.

**AI-enhanced:** Include intelligent agents that can make decisions and use tools.

**Scalable:** Steps run in parallel when possible, and the system scales automatically.

## Common workflow patterns

**Deployment pipeline:**
Tests → Build → Deploy → Verify

**Data processing:**
Extract → Transform → Validate → Load

**Incident response:**
Detect → Analyze → Execute fix → Notify team

**Code review:**
Fetch changes → AI analysis → Post feedback

## Container execution

Every step runs in its own container:

- Use any Docker image (Python, Node.js, custom tools)
- No shared state between steps
- Clean environment for each operation
- Automatic resource management

```python
# Different containers for different tasks
step.analyze(image="python:3.11", script="analyze.py")
step.build(image="node:18", command="npm run build") 
step.deploy(image="kubectl:latest", command="kubectl apply -f app.yaml")
```

## AI integration

Include intelligent agents in workflows:

```python
# AI agent analyzes logs and decides next action
analysis = step.inline_agent(
    message="Analyze these error logs and suggest fixes",
    tools=[log_parser_tool, fix_generator_tool]
)

# Use AI decision in next step
if analysis.severity == "high":
    step.emergency_response()
else:
    step.create_ticket()
```

## Error handling

Built-in resilience patterns:

```python
step.fetch_data(
    retry=3,                    # Retry failed steps
    timeout="5m",              # Set time limits
    on_failure="send_alert"    # Handle failures
)
```

## Getting started

**Define workflow:** Write steps and their dependencies

**Test locally:** Run workflows in development environment

**Deploy to production:** Execute on your infrastructure with runners

**Monitor execution:** Track progress and debug issues

---

**Next:** Try building your first workflow with our [examples](/workflows/examples) or [quick start guide](/getting-started/quickstart). 